# Stack2

과목명: 알고리즘
작성일: 2026년 2월 10일

## 재귀호출

- 함수가 자신과 같은 작업을 반복해야 할 떄, 자신을 다시 호출하는 구조

---

## 피보나치 수열

- 0과 1로 시작하고 이전 두 수의 합을 다음 항으로 하는 수열
- 재귀함수로 구현 가능

```jsx
def fibo(n):
		if n < 2:
				return n
		else:
				return fibo(n-1) + fibo(n-2)
```

---

## 재귀함수

- 현재 호출 단계와 목표 단계를 인자로 사용

```python
def f(i, N):
		if i == N: # 중단조건
				return
		else:      # 재귀 호출
				f(i+1, N)
				
```

```python
# 모든 배열 원소에 접근하는 재귀함수

def f(i, N):
		if i == N:
				return
		else:
				print(arr[i])
				f(i+1, N)
```

```python
# 배열 원소 검색

def f(i, N, V): # V : 찾는 
		if i == N:
				return 0
		elif arr[i] == V:
				return 1
		else:
				return f(i+1, N, V)

```

---

## 메모이제이션

- 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산 X
- 전체적인 실행속도를 빠르게 하는 기술

```python
# 계산된 적이 있는 피보나치 수는 저장된 값을 리턴

# memo를 위한 배열을 할당하고, 모두 0으로 초기화
# memo[0]을 0으로, memo[1]는 1로 초기화

def fibo1(n):
		if n >= 2 and memo[n] == 0:
				memo[n] = fibo1(n-1) + fibo(n-2)
		return memo[n]
		
memo = [0] * (n+1)
memo[0] = 0
memo[1] = 1
```

---

# DP (동적계획법)

- 입력 크기가 작은 부분 문제를 먼저 해결
- 그 결과를 바탕으로 더 큰 부분 문제를 차례대로 해결해 나가며 최종 전체 문제의 해답 도출

---

## 피보나치 수열 - DP 적용

- 문제의 최적 해가 그 하위 문제의 최적 해로부터 쉽게 구성될 수 있는 최적 부분 구조
- 동일한 하위 문제가 여러 번 반복되어 나타나는 중복 부분 문제여야 한다
- 부분 문제로 나누는 일이 끝나면 가장 작은 부분 문제부터 해 구하기
- 그 결과를 테이블에 저장 후, 저장된 부분 문제의 해를 이용하여 상위 문제의 해 구하기

```python
def fibo2(n):
		f = [0] * (n + 1)
		f[0] = 0
		f[1] = 1
		for i in range(2, n+1):
				f[i] = f[i-1] + f[i-2]
				
		return f[n]
```

- Recursive 방식 : fibo1( )
- Iterative 방식 : fibo2 ( )

---

# DFS (깊이 우선 탐색)

- 한 방향으로 가능한 한 깊게 탐색한 후, 더 이상 갈 곳이 없으면 되돌아와 다른 방향을 탐색

---

## 동작 원리

1. 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 나간다.
2. 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점을 되돌아옴
3. 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 탐색 방법

- 가장 마지막에 만났던 갈림길의 정점으로 되돌아가 다시 깊이 우선 탐색 반복해야 하므로 스택 사용
# OOP 2

과목: python
작성일: 2026년 1월 29일

# 상속

한 클래스 (부모)의 속성과 메서드를 다른 클래스 (자식)가 물려받는 것

- 기존 클래스 수정하지 않고 기능 확장 가능
- 부모 클래스와 자식 클래스 간의 관계를 표현하고 더 구체적인 클래스 만들 수 있음
- 코드의 일관성 유지
- 수정이 필요한 범위 최소
- 자식 클래스를 정의할 때 상속하려는 부모 클래스 이름 함께 선언

```python
class Animal:
    def eat(self):
        print('먹는 중')

class Dog(Animal):
    def bark(self):
        print('멍멍')

my_dog = Dog()

my_dog.bark()  # 멍멍

# 부모 클래스(Animal) 메서드 사용 가능
my_dog.eat()  # 먹는 중

```

---

## 클래스 상속

- 상속 없이 구현하는 경우, 학생 / 교수 정보를 별도로 표현 어려움
- Person class만으로 학생, 교수가 가지는 고유 속성 표현하기 어려움

```python
# 상속 없는 경우 - 1
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def talk(self):
        print(f'반갑습니다. {self.name}입니다.')

s1 = Person('김학생', 23)
s1.talk()  # 반갑습니다. 김학생입니다.

p1 = Person('박교수', 59)
p1.talk()  # 반갑습니다. 박교수입니다.
```

- 교수 / 학생 클래스로 각각 선언하여 구현
- 클래스를 분리했지만 메서드가 중복으로 정의될 수 있음

```python
# 상속 없는 경우 - 2
class Professor:
    def __init__(self, name, age, department):
        self.name = name
        self.age = age
        self.department = department

    def talk(self):  # 중복
        print(f'반갑습니다. {self.name}입니다.')

class Student:
    def __init__(self, name, age, gpa):
        self.name = name
        self.age = age
        self.gpa = gpa

    def talk(self):  # 중복
        print(f'반갑습니다. {self.name}입니다.')

```

```python
# 상속을 사용한 계층구조 변경
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def talk(self):  # 메서드 재사용
        print(f'반갑습니다. {self.name}입니다.')

class Professor(Person):
    def __init__(self, name, age, department):
        self.name = name
        self.age = age
        self.department = department

class Student(Person):
    def __init__(self, name, age, gpa):
        self.name = name
        self.age = age
        self.gpa = gpa

p1 = Professor('박교수', 49, '컴퓨터공학과')
s1 = Student('김학생', 20, 3.5)

# 부모 Person 클래스의 talk 메서드를 활용
p1.talk()  # 반갑습니다. 박교수입니다.

# 부모 Person 클래스의 talk 메서드를 활용
s1.talk()  # 반갑습니다. 김학생입니다.
```

---

## 메서드 오버라이딩

- 부모 클래스의 메서드를 같은 이름, 같은 파라미터 구조로 재정의 하는 것
- 동일한 이름, 동일한 매개변수 But, 내부 동작을 원하는 대로 바꿀 수 있음
- 자식 클래스가 부모 클래스의 메서드를 덮어써서 새로운 동작 구현

```python
class Animal:
    def eat(self):
        print('Animal이 먹는 중')

class Dog(Animal):
    # 오버라이딩 (부모 클래스 Animal의 eat 메서드를 재정의)
    def eat(self):
        print('Dog가 먹는 중')

my_dog = Dog()

my_dog.eat()  # Dog가 먹는 중
```

---

### 오버로딩 (파이썬은 미지원)

- 같은 이름, 다른 파라미터를 가진 여러 메서드를 정의하는 것
- 파이썬은 실제로 하나의 메서드만 인식

```python
# 오버로딩 (파이썬 미지원)
class Example:
    def do_something(self, x):
        print('첫 번째 do_something 메서드:', x)

    # 파이썬에서는 메서드가 "이름"이 같으면 앞선 정의를 덮어써버림
    def do_something(self, x, y):
        print('두 번째 do_something 메서드:', x, y)

example = Example()
# TypeError: do_something() missing 1 required positional argument: 'y'
example.do_something(10)
```

---

## 다중 상속

- 둘 이상의 상위 클래스로부터 여러 행동이나 특징을 상속받을 수 있음
- 상속받은 모든 클래스의 요소 활용 가능
- 중복된 속성이나 메서드가 있는 경우, 상속 순서에 의해 결정

```python
# 다중 상속
class Person:
    def __init__(self, name):
        self.name = name

    def greeting(self):
        return f'안녕, {self.name}'

class Mom(Person):
    gene = 'XX'

    def swim(self):
        return '엄마가 수영'

class Dad(Person):
    gene = 'XY'

    def walk(self):
        return '아빠가 걷기'

class FirstChild(Dad, Mom):
    def swim(self):
        return '첫째가 수영'

    def cry(self):
        return '첫째가 응애'

baby1 = FirstChild('아가')
print(baby1.cry())  # 첫째가 응애
print(baby1.swim())  # 첫째가 수영
print(baby1.walk())  # 아빠가 걷기
# print(baby1.gene)  # XY (Dad, Mom) -> Dad부터 상

```

---

## 다이아몬드 문제

B와 C가 재정의한 메서드가 A에 있고 D가 이를 재정의하지 않은 경우

1. 자식 클래스 우선
2. 왼쪽 부모 우선
3. 중복 방문 방지
- 공통 부모 클래스는 모든 자식 클래스의 탐색이 끝난 뒤 단 한번만 탐

---

## 메서드 결정 순서

### MRO

- 파이썬이 메서드를 찾는 순서에 대한 규칙
- 다중 상속에서 어떤 부모 클래스의 메서드를 먼저 사용할지 순서 정의

---

## super() 메서드

- MRO에 따라, 현재 클래스의 부모 클래스의 메서드나 속성에 접근할 수 있게 해주는 내장 함수
- 직접 부모 클래스 이름을 적지 않아도 자동으로 올바른 메서드를 찾아 실행 가능
- 다중 상속에서 super() 호출하면 상속 순서에 맞춰 여러 부모 클래스의 메서드 순차적으로 실행
- 생성자나 오버라이딩 메서드에서 호출하면 부모 클래스의 초기화나 로직 그대로 활용
- 다중 상속에서 올바른 순서(MRO)에 따라 상위 클래스의 메서드를 찾아 실행하기 위해 사용

---

### super() (단일 상속)

- 명시적으로 부모 클래스 이름 적지 않아도 부모 메서드 안전하게 호출
- 부모 클래스의 생성자를 호출하기 위해 사용

```python
# 단일 상속

# super를 사용하지 않았을 때
class Person:
    def __init__(self, name, age, number, email):
        self.name = name
        self.age = age
        self.number = number
        self.email = email

class Student(Person):
    def __init__(self, name, age, number, email, student_id):
        self.name = name
        self.age = age
        self.number = number
        self.email = email
        self.student_id = student_id
```

```python
# super를 사용했을 때
class Person:
    def __init__(self, name, age, number, email):
        self.name = name
        self.age = age
        self.number = number
        self.email = email

class Student(Person):
    def __init__(self, name, age, number, email, student_id):
        # super()를 통해 Person의 __init__ 메서드 호출
        super().__init__(name, age, number, email)
        self.student_id = student_id
```

---

### super() (다중 상속)

- MRO에 따라 각 클래스의 메서드를 찾아감
- 다중 상속 관계에서도 적절한 상위 클래스의 메서드를 안전하게 호출 가능

```python
# 다중 상속
class ParentA:
    def __init__(self):
        #super().__init__()
        self.value_a = 'ParentA'

    def show_value(self):
        print(f'Value from ParentA: {self.value_a}')

class ParentB:
    def __init__(self):
        self.value_b = 'ParentB'

    def show_value(self):
        print(f'Value from ParentB: {self.value_b}')

class Child(ParentA, ParentB):
    def __init__(self):
        super().__init__()  # ParentA 클래스의 __init__ 메서드 호출
        self.value_c = 'Child'

    def show_value(self):
        super().show_value()  # ParentA 클래스의 show_value 메서드 호출
        print(f'Value from Child: {self.value_c}')

child = Child()
child.show_value()
"""
Value from ParentA: ParentA
Value from Child: Child
"""

print(child.value_c)  # Child
print(child.value_a)  # ParentA
print(child.value_b)  # AttributeError: 'Child' object has no attribute 'value_b'

"""
<ParentA에 super().__init__()를 추가하면?>
그 다음으로 ParentB의 __init__가 실행되어 value_b도 초기화할 수 있음
그러면 print(child.value_b)는 ParentB를 출력하게 됨

print(child.value_b)  # ParentB
"""
```

### Child 클래스의 MRO

- Child -> ParentA -> ParentB
- super()는 단순히 직계 부모 클래스를 가리킨다 X
- MRO 순서를 기반으로 “현재 클래스의 다음 순서” 클래스(또는 메서드)를 가리킴
- 따라서 ParentA에서 super()를 부르면 MRO상 다음 클래스인 ParentB.__init__()가 호출됨

---

### 메서드 순서

```python
class A:
    def __init__(self):
        print('A Constructor')

class B(A):
    def __init__(self):
        super().__init__()
        print('B Constructor')

class C(A):
    def __init__(self):
        super().__init__()
        print('C Constructor')

class D(B, C):
    def __init__(self):
        super().__init__()
        print('D Constructor')

# [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
print(D.mro())

# (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)
print(D.__mro__)
```
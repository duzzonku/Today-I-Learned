# Stack

과목명: 알고리즘
작성일: 2026년 2월 9일

# 스택

- 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조

---

## 후입선출 (Last-In-Frist-Out)

- 가장 마지막에 넣은 자료가 가장 먼저 나아ㅗ는 것

---

## Stack의 기본 연산

### 삽입 (Push)

- 저장소에 자료를 저장하는 연산

```python
# append 메소드를 통해 리스트의 마지막에 데이터를 삽입

s = []
def my_push(item):
		s.append(item)
```

```python
# 인덱스 연산을 활용한 구현

def my_push(item, size):
		global top
		top += 1
		if top == size:
				print('Overflow')
		else:
				stack[top] = item
```

```python
# 크기가 정해진 리스트와 인덱스 연산을 활용

size = 10
stack = [0] * size
top = -1

my_push(10, size)
top += 1 # push(20)
stack[top] = 20
```

---

### 삭제 (Pop)

- 저장소에 삽입한 자료의 역순으로 꺼내는 연산

```python
# 남은 데이터 중 가장 늦게 저장된 데이터를 삭제하는 연산

def my_pop():
		if len(s) == 0:
				print('Underflow')
				return
		else:
				return s.pop()
```

```python
# 크기가 정해진 리스트와 인덱스 활용

def my_pop():
		global top
		if top == 1:
				print('Underflow')
				return 0
		else:
				top = -1
				return stack[top+1]
				
print(my_pop())

if top > -1: # pop()
		top -= 1
		print(stack[top+1])
```

---

### 스택이 공백이 아닌지 확인 (isEmpty)

- 스택이 비어있으면 True, 없으면 False 반환

### 스택의 top에 있는 원소를 반환하는 연산 (peek)

- 삭제 X

---

## 스택 구현 시 고려사항

### 1차원 배열을 사용하여 구현할 경우

- 장점 : 구현에 용이
- 단점 : 스택의 크기 변경 어려움
- 해결 방법 : 저장소를 동적으로 할당하여 스택을 구현
    - 장점 : 메모리를 효율적으로 사용
    - 단점 : 구현이 복잡

---

# 괄호 검사

## 괄호의 종류

- 대괄호 : [ ]
- 중괄호 : { }
- 소괄호 : ( )

---

### 조건

- 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다
- 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다
- 괄호 사이에는 포함 관계만 존재한다.

---

## 괄호를 검사하는 알고리즘

1. 문자열에 있는 괄호를 차례대로 검사
2. 왼쪽 괄호를 만나면 스택에 삽입
3. 오른쪽 괄호를 만나면 스택에서 top 괄호를 삭제한 후 오른쪽 괄호와 짝이 맞는지를 검사
4. 이 때, 스택이 비어 있으면 조건 1 또는 조건 2에 위배되고 괄호의 짝이 맞지 않으면 조건 3에 위배
5. 마지막 괄호까지 조사한 후에도 스택에 괄호가 남아있으면 조건 1에 위배

---

# Function Call

- 프로그램에서 함수 호출과 복귀에 따른 수행 순서 관리
- 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조
- 후입선출 구조의 스택을 이용하여 수행순서 관리

---

## 시스템 스택

- 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 저장
- 함수 호출이 발생하면 스택 프레임에 저장하여 시스템 스택에 삽